# Prime Problem

## Only in C

I don't love hard-coding the primes lower than 10 but damned if I could figure
out how to calculate them. Throwing out all even numbers seems more efficient
than just checking if a given number is divisible by the iterator.

I also found that `sizeof()` behaved differently locally than remotely and had
to implement the wonky \`sizeof(arrray) / sizeof(array\[0\]) to get a legitimate
array size. Unsure how I got away with it before.

```
➜  CS50 git:(prime) ✗ cd prime; cschecker cs50/labs/2023/x/prime; cd -
Connecting.........
Authenticating...
Verifying........
Preparing........
Uploading.........
Waiting for results...............
Results for cs50/labs/2023/x/prime generated by check50 v3.3.11
:) prime.c exists
:) prime.c compiles
:) Input of 1 and 10 yields all prime numbers between 1 and 10, inclusive
:) Input of 10 and 25 yields all prime numbers between 10 and 25, inclusive
:) Input of 50 and 60 yields all prime numbers between 50 and 60, inclusive
```

## Preserved comment from @jgopel regarding refactoring the prime function to handle larger inputs

*issue*: This is only working because of the constraints of your data sets. If
you had a large min and a much larger max, this would probably fail because you
only consider divisors of 3-10. I think this problem is intended to teach you
algorithm design - so I'll run through my approach there.

```
What does it mean for a number to be prime? A number is prime if it has no divisors (other than 1 and itself)
Are there any special cases? Yes - 1 is held to be not prime as a foundational principle.
```

So that establishes the basic shape of the the algorithm:

```
bool prime(int number) {
  if (number == 1) {
    return false;
  }
  return num_divisors(number) == 0;
}
```

Hooray! All done! Oh, except num_divisors() doesn't exist. Dang it. Ok - new
algorithm time. Requirements gathering:

```
What is the divisor of a number? It's any number that divides it evenly.
Are there any special cases? Yes - a number will never be evenly divisible by anything in the range n/2 - n.
```

This leads me to think of a brute force approach where I check every number from
2 through n/2. Any time I land on a brute force approach, I take a moment to
think about whether or not a more efficient solution exists. Here a quick Google
search yields that the best result is actually to guess and check. That actually
makes intuitive sense to me as prime number factorization is a key area of
cryptography due to its computational expense.

Ok, so lets write our new algorithm:

```
int num_divisors(int number) {
  int output = 0;
  for (int divisor = 2; divisor <= number / 2; ++divisor) {
    if (number % divisor == 0) {
      output += 1;
    }
  }
  return output;
}
```

Hooray! This time for real.

We've now gone from red, to green - next step is refactor. Let's take a step
back and consider what we have - is there anything we could be doing better?
Something that stands out to me is that we're computing ALL the factors just to
find out if there are any. That's not efficient. Perhaps our compiler would see
through that and optimize it, but I wouldn't want to count on that if
performance matters. So what we need here is a more specialized algorithm to
reduce duplicate work.

```
bool prime(int number) {
  if (number == 1) {
    return false;
  }
  for(int divisor = 2; divisor <= number / 2; ++divisor) {
    if (number % divisor == 0) {
      return true;
    }
  }
}
```

Nice - a clean refactor that eliminates duplicate work. A couple of final
thoughts here:

```
I wonder if num_divisors() could be made faster by only checking a quarter of the range and adding factors in pairs. Consider the number 10 - when I find the divisor 2, I also know that 5 is a divisor. I'd need to think about this to prove to myself that it's a valid approach (and handle cases like 9 divided by 3, which only has the 1 factor). I'm letting that ride because we didn't end up using it and terminating early serves the same effect.
We need to be careful of negative numbers here. The algorithm as-written will perform unpredictably with negative numbers.
```
